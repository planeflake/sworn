# --- START OF FILE app/game_state/managers/world_manager.py ---

"""
World Manager - Contains domain logic for world operations
"""

from app.game_state.entities.world.world_pydantic import WorldEntityPydantic
from typing import Optional
from uuid import UUID, uuid4
import logging 

class WorldManager:
    """Manager class for world-specific domain logic"""

    @staticmethod
    async def create_world(name: Optional[str] = None) -> WorldEntityPydantic:
        """
        Create a new world entity object in memory with provided or default values.
        Does NOT save to the database.
        """
        # Use provided values or defaults defined in the Pydantic model
        world_data = {
            # No need to include id - it will be generated by PostgreSQL
            **( {"name": name} if name is not None else {} )
        }

        world_entity = WorldEntityPydantic(**world_data)
        logging.info(f"Created transient WorldEntityPydantic in memory: name='{world_entity.name}'")
        return world_entity

    @staticmethod
    async def increment_day(world: WorldEntityPydantic) -> WorldEntityPydantic:
        """
        Increment the day counter of the world entity.
        Potentially triggers other day-based logic (e.g., season change).
        Modifies the passed entity object.

        Args:
            world: The WorldEntity instance to modify.

        Returns:
            The modified WorldEntity instance.
        """
        if not isinstance(world, WorldEntityPydantic):
                # Add type check for safety if needed
                raise TypeError("increment_day expects a WorldEntityPydantic object")

        world.day += 1
        logging.debug(f"Incremented day for world {world.entity_id} to {world.day}")

        # --- Future Domain Logic ---
        # world = await WorldManager.update_season(world)
        # world = await WorldManager.generate_weather(world)
        # world = await WorldManager.trigger_daily_events(world)
        # world = await WorldManager.update_resources(world)
        # --- End Future Logic ---

        # Return the same object, modified in place
        return world

    # --- Future methods focusing on domain logic ---

    # @staticmethod
    # async def update_season(world: WorldEntity) -> WorldEntity:
    #     """Update the season based on the current day."""
    #     # Assumes WorldEntity has a 'season' attribute
    #     seasons = ["spring", "summer", "fall", "winter"]
    #     days_per_season = 90 # Example
    #     current_season_index = (world.game_day // days_per_season) % len(seasons)
    #     new_season = seasons[current_season_index]
    #     if world.season != new_season:
    #         world.season = new_season
    #         logging.info(f"World {world.id} season changed to {new_season}")
    #     return world

    # @staticmethod
    # async def generate_weather(world: WorldEntity) -> WorldEntity:
    #     """Generate weather conditions based on season, climate, randomness."""
    #     # Assumes WorldEntity has a 'weather' attribute
    #     # Complex logic based on world.climate, world.season etc.
    #     # world.weather = "sunny" # Placeholder
    #     # logging.debug(f"Generated weather for world {world.id}: {world.weather}")
    #     return world

    # Add other manager methods for pure domain logic...